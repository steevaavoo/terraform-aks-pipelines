# Continuous integration (CI) triggers cause a build to run whenever a push is made to the specified branches
# or a specified tag is pushed.
# YAML builds are configured by default with a CI trigger on all branches.
trigger:
  batch: "false"
  branches:
    include:
    - master
    - develop

# A pull request will not trigger a build
pr: none

# If your pipeline has templates in another repository, you must let the system know about that repository.
# The repository resource lets you specify an external repository.
# In this case "self" means "the repository that the YAML file is in". Though it
# should not be necessary.
resources:
  repositories:
    - repository: self

variables:
- group: my-variable-group
- name: poolName
  value: 'ubuntu-latest'
- name: terraformstoragerg
  value: 'terraformrg'
- name: terraformstorageaccount
  value: 'terraformstoragestv22f79'
- name: serviceConnection
  value: 'aks_sc'
- name: aksclustername
  value: 'stvaks1'
- name: aksrgname
  value: 'stvRG1'
- name: ClientID
  value: 'http://tfm-k8s-spn'
- name: storagekey
  value: 'willbefetchedbyscript'

stages:
- stage: Build
  displayName: Build stage
  jobs:
  - job: Build
    displayName: Build job
    pool:
      vmImage\: $(poolName)
    steps:
    - task: CopyFiles@2
      displayName: 'Copy Terraform files to artifacts'
      inputs:
        SourceFolder: terraform
        TargetFolder: '$(Build.ArtifactStagingDirectory)/Terraform'

    - task: CopyFiles@2
      displayName: 'Copy K8s YAML files to artifacts'
      inputs:
        SourceFolder: manifests
        TargetFolder: '$(Build.ArtifactStagingDirectory)/manifests'

    - publish: $(Build.ArtifactStagingDirectory)
      artifact: drop

- stage: Deploy
  jobs:
    # track deployments on the environment
  - deployment: 'NginxDemo_Release_Pipeline'
    pool:
      vmImage: 'vs2017-win2016'
    # creates an environment if it doesnâ€™t exist
    environment: 'dev'
    strategy:
      # default deployment strategy
      runOnce:
        deploy:
          steps:
          # the following script will create an Azure resource group, Storage account and Storage container which will be used to store terraform remote state
          - task: AzureCLI@1
            displayName: 'Azure CLI to deploy Storage for Terraform Remote'
            inputs:
              azureSubscription: $(serviceConnection)
              scriptLocation: 'inlineScript'
              inlineScript: |
                call az group create --location eastus --name $(terraformstoragerg)
                call az storage account create --name $(terraformstorageaccount) --resource-group $(terraformstoragerg) --location eastus --sku Standard_LRS
                call az storage container create --name terraform --account-name $(terraformstorageaccount)

          - task: AzurePowerShell@3
            displayName: 'Azure PowerShell script to get Storage Key'
            inputs:
              azureSubscription: $(serviceConnection)
              ScriptType: InlineScript
              Inline: |
                # Using this script we will fetch the storage key which is required in our Terraform file to authenticate to the backend storage account

                $key=(Get-AzureRmStorageAccountKey -ResourceGroupName $(terraformstoragerg) -AccountName $(terraformstorageaccount)).Value[0]

                Write-Host "##vso[task.setvariable variable=storagekey]$key"

              azurePowerShellVersion: latestVersion

          - task: qetza.replacetokens.replacetokens-task.replacetokens@3
            displayName: 'Replace tokens in **/*.tf'
            inputs:
              targetFiles: '$(Pipeline.Workspace)/Drop/Terraform/*.tf'
              escapeType: none
              tokenPrefix: '__'
              tokenSuffix: '__'

          - task: petergroenewegen.PeterGroenewegen-Xpirit-Vsts-Release-Terraform.Xpirit-Vsts-Release-Terraform.Terraform@2
            displayName: 'Terraform Init'
            inputs:
              TemplatePath: '$(Pipeline.Workspace)/Drop/Terraform'
              Arguments: init
              InstallTerraform: true
              UseAzureSub: true
              ConnectedServiceNameARM: $(serviceConnection)

          - task: petergroenewegen.PeterGroenewegen-Xpirit-Vsts-Release-Terraform.Xpirit-Vsts-Release-Terraform.Terraform@2
            displayName: 'Terraform Plan'
            inputs:
              TemplatePath: '$(Pipeline.Workspace)/Drop/Terraform'
              Arguments: plan
              InstallTerraform: true
              UseAzureSub: true
              ConnectedServiceNameARM: $(serviceConnection)

          - task: petergroenewegen.PeterGroenewegen-Xpirit-Vsts-Release-Terraform.Xpirit-Vsts-Release-Terraform.Terraform@2
            displayName: 'Terraform Apply -auto-approve'
            inputs:
              TemplatePath: '$(Pipeline.Workspace)/Drop/Terraform'
              Arguments: 'apply -auto-approve'
              InstallTerraform: true
              UseAzureSub: true
              ConnectedServiceNameARM: $(serviceConnection)

          - task: KubectlInstaller@0
            displayName: 'Install Kubectl latest'

          - task: Kubernetes@1
            displayName: 'kubectl - (Resource Manager) Deploy nginxdemo Deployment'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: '$(serviceConnection)'
              azureResourceGroup: '$(aksrgname)'
              kubernetesCluster: '$(aksclustername)'
              command: apply
              arguments: '-f $(Pipeline.Workspace)/Drop/manifests/deployment.yml'

          - task: Kubernetes@1
            displayName: 'kubectl - (Resource Manager) Deploy nginxdemo Service'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: '$(serviceConnection)'
              azureResourceGroup: '$(aksrgname)'
              kubernetesCluster: '$(aksclustername)'
              command: apply
              arguments: '-f $(Pipeline.Workspace)/Drop/manifests/service.yml'